# A0141052Y
###### \java\seedu\task\commons\events\ui\SwitchCommandBoxFunctionEvent.java
``` java
package seedu.task.commons.events.ui;

import seedu.task.commons.events.BaseEvent;

/**
 * Indicates that the CommandBox functionality should switch
 * @author Syed Abdullah
 *
 */
public class SwitchCommandBoxFunctionEvent extends BaseEvent {
    
    public SwitchCommandBoxFunctionEvent() { }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\task\logic\commands\FindTagCommand.java
``` java
package seedu.task.logic.commands;

import java.util.HashSet;
import java.util.Set;

import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.model.tag.Tag;

public class FindTagCommand extends Command {

    public static final String COMMAND_WORD = "find-tags";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks that contains all of the specified tags (case-sensitive).\n"
            + "Parameters: TAG_NAME [MORE_TAG_NAMES]...\n"
            + "Example: " + COMMAND_WORD + " homework cs1101s";

    private final Set<Tag> tags;

    /**
     * Constructs a find-tags command
     * @param tagNames a list of tag names to search for
     * @throws IllegalValueException thrown if the tag names are not valid
     */
    public FindTagCommand(String[] tagNames) throws IllegalValueException {
        this.tags = new HashSet<Tag>();
        for (String tagName : tagNames) {
            this.tags.add(new Tag(tagName));
        }
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredListByTags(tags);
        return new CommandResult(true, getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### \java\seedu\task\logic\commands\ListCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.model.Model;

/**
 * Lists all tasks in the task list to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Lists a subset of the tasks in the list "
            + "Parameters: [all|pinned|pending|completed|overdue]...\n"
            + "Example: " + COMMAND_WORD
            + " ALL";

    public static final String MESSAGE_SUCCESS = "Filtered tasks listed.";
    
    private final Model.FilterType listFilter;

    public ListCommand(Model.FilterType filter) {
        this.listFilter = filter;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredList(listFilter);
        return new CommandResult(true, MESSAGE_SUCCESS);
    }
}
```
###### \java\seedu\task\logic\commands\SearchCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.commons.core.EventsCenter;
import seedu.task.commons.events.ui.SwitchCommandBoxFunctionEvent;

public class SearchCommand extends Command {
    
    public static final String MESSAGE_SEARCH_SUCCESS = "Live Search activated!";

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new SwitchCommandBoxFunctionEvent());
        return new CommandResult(true, MESSAGE_SEARCH_SUCCESS);
    }
}
```
###### \java\seedu\task\logic\Logic.java
``` java
    /**
     * Updates the task list filter with the specified keyword
     * @param keyword to be used to filter the tasks
     */
    void updateTaskListFilter(String keyword);
```
###### \java\seedu\task\logic\LogicManager.java
``` java
    @Override
    public void updateTaskListFilter(String keyword) {
        model.updateFilteredTaskList(new HashSet<String>(Arrays.asList(keyword)));
    }
    
    private void setPreviousCommand(boolean isSuccessful, Command command) {
        if (isSuccessful && command instanceof UndoableCommand) {
            this.previousCommand = (UndoableCommand) command;
        } else {
            this.previousCommand = null;
        }
    }
}
```
###### \java\seedu\task\logic\parser\AddParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.HashSet;
import java.util.Set;
import java.util.StringJoiner;


import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.commands.AddCommand;
import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;

public class AddParser extends BaseParser {
    
    private final static String FLAG_NAME = "name";
    private final static String FLAG_START_TIME = "starts";
    private final static String FLAG_CLOSE_TIME = "ends";
    private final static String FLAG_TAGS = "tag";
    
    private final static String[] KEYWORD_ARGS_REQUIRED = new String[]{FLAG_NAME};
    private final static String[] KEYWORD_ARGS_OPTIONAL = new String[]{FLAG_START_TIME,
            FLAG_CLOSE_TIME,
            FLAG_TAGS
    };
        
    @Override
    public Command parse(String command, String arguments) {
        this.extractArguments(arguments);
        if (!checkForRequiredArguments(KEYWORD_ARGS_REQUIRED, KEYWORD_ARGS_OPTIONAL, true)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        
        try {
            return new AddCommand(getSingleKeywordArgValue(FLAG_NAME),
                    getSingleKeywordArgValue(FLAG_START_TIME),
                    getSingleKeywordArgValue(FLAG_CLOSE_TIME),
                    getTags());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
    
    private Set<String> getTags() {
        if (argumentsTable.containsKey(FLAG_TAGS)) {
            return new HashSet<>(argumentsTable.get(FLAG_TAGS));
        } else {
            return new HashSet<>();
        }
    }
    
```
###### \java\seedu\task\logic\parser\BaseParser.java
``` java
package seedu.task.logic.parser;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Optional;
import java.util.StringJoiner;

import seedu.task.commons.util.StringUtil;
import seedu.task.logic.commands.Command;

public abstract class BaseParser {
    
    protected final HashMap<String, ArrayList<String>> argumentsTable = new HashMap<>();
        
    /**
     * Extracts out arguments from the user's input into a HashMap.
     * The value mapped to the empty string ("") is the non-keyword argument.
     * 
     * @param args full (or partial) user input arguments
     */
    protected void extractArguments(String args) {
        argumentsTable.clear();
        String[] segments = args.trim().split(" ");
        String currentKey = "";
        StringJoiner joiner = new StringJoiner(" ");
        
        for (String segment : segments) {
            joiner.add(segment);
            
        }
        
        addToArgumentsTable(currentKey, joiner.toString());
    }
    
    /**
     * Assigns a value to a keyword argument. Does not replace any existing
     * values associated with the keyword.
     * @param keyword the keyword of the argument
     * @param value the value the argument is set to
     */
    protected void addToArgumentsTable(String keyword, String value) {
        ArrayList<String> arrayItems;
        if (argumentsTable.containsKey(keyword)) {
            arrayItems = argumentsTable.get(keyword);
        } else {
            arrayItems = new ArrayList<String>();
        }
        
        arrayItems.add(value);
        argumentsTable.put(keyword, arrayItems);
    }
    
    /***
     * Checks if the required keyword arguments were supplied by the user
     * @param requiredArgs list of keyword arguments
     * @param optionalArgs list of arguments that may appear
     * @param isStrictSet does not allow for other keyword arguments
     * @return true if required arguments were supplied, else false
     */
    protected boolean checkForRequiredArguments(String[] requiredArgs, String[] optionalArgs, boolean isStrictSet) {
        for (String arg : requiredArgs) {
            if (!argumentsTable.containsKey(arg)) {
                return false;
            } else {
                if (argumentsTable.get(arg).get(0).isEmpty()) {
                    return false;
                }
            }
        }
        
        int numOptional = 0;
        for (String arg : optionalArgs) {
            if (argumentsTable.containsKey(arg)) {
                numOptional++;
            }
        }
        
        if (isStrictSet) {
            return argumentsTable.size() == numOptional + requiredArgs.length;
        } else {
            return argumentsTable.size() >= numOptional + requiredArgs.length;
        }
    }
    
    /**
     * Retrieves the value for the keyword argument
     * @param keyword the keyword of the argument
     * @return the current value of the keyword argument
     */
    protected String getSingleKeywordArgValue(String keyword) {
        if (argumentsTable.containsKey(keyword)) {
            return argumentsTable.get(keyword).get(0);
        } else {
            return null;
        }
    }
    
    /**
     * Returns a positive integer, if the user supplied unnamed keyword argument is a positive integer.
     * Returns an {@code Optional.empty()} otherwise.
     */
    protected Optional<Integer> parseIndex() {
        String index = getSingleKeywordArgValue("");
        return parseIndex(index);
    }
    
    protected Optional<Integer> parseIndex(String index) {
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));
    }
    
    /**
     * Parses the user's input and determines the appropriate command
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public abstract Command parse(String command, String arguments);
}
```
###### \java\seedu\task\logic\parser\ClearParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.ClearCommand;
import seedu.task.logic.commands.Command;

public class ClearParser extends BaseParser {
    @Override
    public Command parse(String command, String arguments) {
        return new ClearCommand();
    }
}
```
###### \java\seedu\task\logic\parser\CompleteParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.CompleteCommand;
import seedu.task.logic.commands.IncorrectCommand;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.task.logic.commands.Command;

public class CompleteParser extends BaseParser {
    @Override
    public Command parse(String command, String arguments) {
        this.extractArguments(arguments);
        Optional<Integer> idx = parseIndex();
        
        if (!idx.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }
        
        return new CompleteCommand(idx.get());
    }
}
```
###### \java\seedu\task\logic\parser\DeleteParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.DeleteCommand;
import seedu.task.logic.commands.IncorrectCommand;

public class DeleteParser extends BaseParser {
    @Override
    public Command parse(String command, String arguments) {
        this.extractArguments(arguments);
        
        Optional<Integer> index = parseIndex();
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(index.get());
    }
}
```
###### \java\seedu\task\logic\parser\ExitParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ExitCommand;

public class ExitParser extends BaseParser {
    @Override
    public Command parse(String command, String arguments) {
        return new ExitCommand();
    }
}
```
###### \java\seedu\task\logic\parser\FindParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.FindCommand;
import seedu.task.logic.commands.IncorrectCommand;

public class FindParser extends BaseParser {
    @Override
    public Command parse(String command, String arguments) {
        // keywords delimited by whitespace
        
        if (arguments.trim().isEmpty()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }
        
        final String[] keywords = arguments.split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }
}
```
###### \java\seedu\task\logic\parser\FindTagParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.FindTagCommand;
import seedu.task.logic.commands.IncorrectCommand;

public class FindTagParser extends BaseParser {

    @Override
    public Command parse(String command, String arguments) {
        if (arguments.trim().isEmpty()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindTagCommand.MESSAGE_USAGE));
        }
        
        final String[] tagNames = arguments.split("\\s+");
        try {
            return new FindTagCommand(tagNames);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

}
```
###### \java\seedu\task\logic\parser\HelpParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.HelpCommand;

public class HelpParser extends BaseParser {
    @Override
    public Command parse(String command, String arguments) {
        return new HelpCommand();
    }
}
```
###### \java\seedu\task\logic\parser\ListParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.logic.commands.ListCommand;
import seedu.task.model.Model.FilterType;

public class ListParser extends BaseParser {
    
    private final String FLAG_LIST_TYPE = "";
    
    private final String[] KEYWORD_ARGS_REQUIRED = new String[]{FLAG_LIST_TYPE};
    private final String[] KEYWORD_ARGS_OPTIONAL = new String[]{};
    
    @Override
    public Command parse(String command, String arguments) {
        this.extractArguments(arguments);
        if (!this.checkForRequiredArguments(KEYWORD_ARGS_REQUIRED, KEYWORD_ARGS_OPTIONAL, true)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        }
        
        FilterType filter = FilterType.ALL;
        
        switch (getSingleKeywordArgValue(FLAG_LIST_TYPE)) {
        case "all":
            break;
        case "pinned":
            filter = FilterType.PIN;
            break;
        case "pending":
            filter = FilterType.PENDING;
            break;
        case "completed":
            filter = FilterType.COMPLETED;
            break;
        case "overdue":
            filter = FilterType.OVERDUE;
            break;
        default:
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        }
        
        return new ListCommand(filter);
    }
}
```
###### \java\seedu\task\logic\parser\ParserMapping.java
``` java
package seedu.task.logic.parser;

import java.util.HashMap;
import java.util.Optional;
import java.util.logging.Logger;
import seedu.task.commons.core.LogsCenter;
import seedu.task.commons.logic.CommandKeys;
import seedu.task.commons.logic.CommandKeys.Commands;

/**
 * Provides command word and alias mappings
 * @author Syed Abdullah
 *
 */
public class ParserMapping {
    private HashMap<Commands, Class<? extends BaseParser>> mappingTable = new HashMap<>();
    private final Logger logger = LogsCenter.getLogger(ParserMapping.class);
    private final HashMap<String, Commands> aliasMappings;
    
    public ParserMapping(HashMap<String, Commands> aliasMappings) {
        populateMappings();
        this.aliasMappings = aliasMappings;
    }
       
    /**
     * Populates the command word to command parsers mapping table
     */
    private void populateMappings() {
        mappingTable.put(Commands.ADD, AddParser.class);
        mappingTable.put(Commands.ALIAS, AliasParser.class);
        mappingTable.put(Commands.CLEAR, ClearParser.class);
        mappingTable.put(Commands.COMPLETE, CompleteParser.class);
        mappingTable.put(Commands.CHANGE_TO, ChangePathParser.class);
        mappingTable.put(Commands.DELETE, DeleteParser.class);
        mappingTable.put(Commands.EXIT, ExitParser.class);
        mappingTable.put(Commands.FIND, FindParser.class);
        mappingTable.put(Commands.FIND_TAG, FindTagParser.class);
        mappingTable.put(Commands.HELP, HelpParser.class);
        mappingTable.put(Commands.LIST, ListParser.class);
        mappingTable.put(Commands.PIN, PinParser.class);
        mappingTable.put(Commands.SEARCH_BOX, SearchParser.class);
        mappingTable.put(Commands.SELECT, SelectParser.class);
        mappingTable.put(Commands.UNDO, UndoParser.class);
        mappingTable.put(Commands.UPDATE, UpdateParser.class);
        mappingTable.put(Commands.UNCOMPLETE, UncompleteParser.class);
        mappingTable.put(Commands.UNPIN, UnpinParser.class);
    }

    /**
     * Retrieves commands for a specified keyword
     * @param commandWord
     * @return
     */
    public Optional<Class<? extends BaseParser>> getParserForCommand(String commandWord) {        
        
        //check if it's an alias
        if(aliasMappings.containsKey(commandWord) && aliasMappings.get(commandWord) != null) {
            Commands command = aliasMappings.get(commandWord);
            return Optional.of(mappingTable.get(command));
        } 
        
        if (CommandKeys.commandKeyMap.containsKey(commandWord) && CommandKeys.commandKeyMap.get(commandWord) != null) {
            Commands command = CommandKeys.commandKeyMap.get(commandWord);
            return Optional.of(mappingTable.get(command));
        } else {
            logger.info("[USER COMMAND][" + commandWord + "] not found!");
            return Optional.empty();
        }
    }
}
```
###### \java\seedu\task\logic\parser\ParseSwitcher.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;
import static seedu.task.commons.core.Messages.MESSAGE_INTERNAL_ERROR;

import java.util.HashMap;
import java.util.Optional;

import seedu.task.commons.logic.CommandKeys.Commands;
import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;

/**
 * ParseSwitcher -- parses the raw command from user and delegates the
 * parsing to the specific command parsers for further parsing.
 * 
 * @author Syed Abdullah
 *
 */
public class ParseSwitcher {
    private final ParserMapping parserMappings;
        
    public ParseSwitcher(HashMap<String, Commands> aliasMappings) { 
         parserMappings = new ParserMapping(aliasMappings);

    }

    /**
     * Parses the user's input and determines the appropriate command
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        String[] commandSegments = userInput.split(" ", 2);
        final String commandWord = (commandSegments.length > 0) ? commandSegments[0] : "";
        final String commandArgs = (commandSegments.length > 1) ? commandSegments[1] : "";
        
        Optional<Class<? extends BaseParser>> selectedParser = parserMappings.getParserForCommand(commandSegments[0]);
        
        if (!selectedParser.isPresent()) {
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        } else {
            BaseParser parser;
            try {
                parser = selectedParser.get().newInstance();
                return parser.parse(commandWord, commandArgs);
            } catch (InstantiationException | IllegalAccessException e) {
                e.printStackTrace();
                return new IncorrectCommand(MESSAGE_INTERNAL_ERROR);
            }
        }
    }
}
```
###### \java\seedu\task\logic\parser\PinParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.logic.commands.PinCommand;

public class PinParser extends BaseParser {
    @Override
    public Command parse(String command, String arguments) {
        this.extractArguments(arguments);
        
        Optional<Integer> index = parseIndex();
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, PinCommand.MESSAGE_USAGE));
        }
        return new PinCommand(index.get());
    }
}
```
###### \java\seedu\task\logic\parser\SearchParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.SearchCommand;

public class SearchParser extends BaseParser {

    @Override
    public Command parse(String command, String arguments) {
        return new SearchCommand();
    }

}
```
###### \java\seedu\task\logic\parser\SelectParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.logic.commands.SelectCommand;

public class SelectParser extends BaseParser {
    @Override
    public Command parse(String command, String arguments) {
        this.extractArguments(arguments);
        
        Optional<Integer> index = parseIndex();
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        return new SelectCommand(index.get());
    }
}
```
###### \java\seedu\task\logic\parser\UndoParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.UndoCommand;

public class UndoParser extends BaseParser {
    @Override
    public Command parse(String command, String arguments) {
        return new UndoCommand();
    }
}
```
###### \java\seedu\task\logic\parser\UpdateParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.StringJoiner;

import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.logic.commands.UpdateCommand;

public class UpdateParser extends BaseParser {
    private final static String FLAG_NAME = "name";
    private final static String FLAG_START_TIME = "starts";
    private final static String FLAG_CLOSE_TIME = "ends";
    private final static String FLAG_TAGS = "tag";
    private final static String FLAG_REMOVE_TAGS = "remove-tag";
    private final static String[] KEYWORD_ARGS_OPTIONAL = new String[]{
            FLAG_NAME,
            FLAG_START_TIME,
            FLAG_CLOSE_TIME,
            FLAG_TAGS,
            FLAG_REMOVE_TAGS
    };
```
###### \java\seedu\task\model\history\ListMutation.java
``` java
package seedu.task.model.history;

import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Set;

/**
 * Represents a state change for an indexed List
 * @author Syed Abdullah
 *
 * @param <T>
 */
public class ListMutation<T> {
    private final HashMap<Integer, Mutation<T>> mutationMap;
    
    /**
     * Constructs an empty ListMutation
     */
    public ListMutation() {
        this.mutationMap = new HashMap<Integer, Mutation<T>>();
    }
    
    /**
     * Add a Mutation of a specified index in the list
     * 
     * @param index the index of the element in the list
     * @param mutation the Mutation of the element in the list
     */
    public void addMutation(int index, Mutation<T> mutation) {
        this.mutationMap.put(index, mutation);
    }
    
    /**
     * Adds a new Mutation for an element, treating it as a new mutation for the list
     * 
     * @param index the index of the element in the list
     * @param mutation the Mutation of the element in the list 
     */
    public void addAsNewMutation(int index, Mutation<T> mutation) {
        this.clear();
        this.addMutation(index, mutation);
    }
    
    /**
     * Adds new Mutations for consecutive elements inserted into list. Method will create a new Mutation
     * 
     * @param startIndex the starting position (inclusive)
     * @param newElements the array of elements that are added
     */
    public void addNewElements(int startIndex, T[] newElements) {
        this.clear();
        for (int i = startIndex; i < newElements.length; i++) {
            this.mutationMap.put(i, new Mutation<T>(null, newElements[i - startIndex]));
        }
    }
    
    /**
     * Mutates an element in the specified index to the next state
     * 
     * @param index the index of the element in the list
     * @param currentState the current state of the element
     * @param nextState the next state of the element
     */
    public void mutateElement(int index, T nextState) {
        Mutation<T> newMutation;
        if (this.mutationMap.containsKey(index)) {
            Mutation<T> currentMutation = this.mutationMap.get(index);
            newMutation = currentMutation.transitionToNextState(nextState);
        } else {
            newMutation = new Mutation<T>(null, nextState);
        }
        this.mutationMap.put(index, newMutation);
    }
    
    /**
     * Retrieves a mapping of element mutations for the list
     * @return set of element mutations entries for the list
     */
    public Set<Entry<Integer, Mutation<T>>> getMutations() {
        return this.mutationMap.entrySet();
    }
    
    /**
     * Checks if there is any mutations that are recorded.
     * 
     * @return true if there is any mutation, else false
     */
    public boolean hasMutation() {
        return !this.mutationMap.isEmpty();
    }
    
    /**
     * Clears the ListMutation
     */
    public void clear() {
        this.mutationMap.clear();
    }
}
```
###### \java\seedu\task\model\history\Mutation.java
``` java
package seedu.task.model.history;

/**
 * Represents an object state change.
 * @author Syed Abdullah
 *
 * @param <T> the object's Class
 */
public class Mutation<T> {
    
    final private T previousState;
    final private T presentState;
    
    /**
     * Constructs a Mutation.
     * 
     * @param previousState the state of the instance before mutation
     * @param presentState the state of the instance after mutation
     */
    public Mutation(T previousState, T presentState) {
        this.previousState = previousState;
        this.presentState = presentState;
    }
    
    /**
     * Get the state before mutation
     * @return state of object before mutation took place
     */
    public T getPreviousState() {
        return previousState;
    }
    
    /**
     * Get the state after mutation
     * @return state of object before mutation took place
     */
    public T getPresentState() {
        return presentState;
    }
    
    /**
     * Transitions the current mutation to the next mutation
     * 
     * @param state the next state to transit to
     * @return a new Mutation from the current state to the next state
     */
    public Mutation<T> transitionToNextState(T state) {
        return new Mutation<T>(this.getPresentState(), state);
    }
    
    /**
     * Reverses the mutation (e.g. A->B becomes B->A)
     * @return a reversed mutation
     */
    public Mutation<T> reverse() {
        return new Mutation<T>(this.getPresentState(), this.getPreviousState());
    }
}
```
###### \java\seedu\task\model\Model.java
``` java
    /** Updates the filter of the filtered task list to show based on the preset **/
    void updateFilteredList(FilterType filter);
    
    /** Updates the filter to show based on a list of tags provided **/
    void updateFilteredListByTags(Set<Tag> tags);
```
###### \java\seedu\task\model\ModelManager.java
``` java
    @Override
    public void updateFilteredList(FilterType filter) {
        
        updateFilteredListToShowAll();
        
        switch (filter) {
        case ALL:
            updateFilteredListToShowAll();
            break;
            
        case PIN:
            updateFilteredTaskList(new PredicateExpression(new PinQualifier(true)));
            break;
            
        case COMPLETED:
            updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(true)));
            break;
        
        case PENDING:
            updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(false)));
            break;
            
        case OVERDUE:
            DateTime now = DateTime.fromEpoch(System.currentTimeMillis());
            updateFilteredTaskList(new PredicateExpression(new DueDateQualifier(now)));
            break;
            
        default:
            // does nothing
            break;
        }
    }
    
    public void updateFilteredListByTags(Set<Tag> tags) {
        updateFilteredTaskList(new PredicateExpression(new TagQualifier(tags)));
    }
```
###### \java\seedu\task\model\ModelManager.java
``` java
    // ========== Methods for sorting ==========================================================================
    
    private int totalOrderSorting(Task task, Task otherTask) {
        return task.compareTo(otherTask);
    }
```
###### \java\seedu\task\model\ModelManager.java
``` java
    /**
     * Qualifier that checks for matching tags
     * @author Syed Abdullah
     *
     */
    private class TagQualifier implements Qualifier {
        private Set<Tag> tags;

        TagQualifier(Set<Tag> tags) {
            this.tags = tags;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return tags.stream()
                    .allMatch(tag -> task.getTags().contains(tag));
        }
    }
    
    /**
     * Qualifier that checks if Task is not due based on reference time
     * @author Syed Abdullah
     *
     */
    private class DueDateQualifier implements Qualifier {
        
        private DateTime referencePoint;
        
        DueDateQualifier(DateTime reference) {
            this.referencePoint = reference;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            DateTime toCompare = task.getCloseTime();
            
            if (toCompare.isEmpty()) {
                return false;
            } else {
                return (toCompare.compareTo(this.referencePoint) < 1);
            }
        }
    }
    
    /**
     * Qualifier to check the Pin property of the underlying Task.
     * @author Syed Abdullah
     *
     */
    private class PinQualifier implements Qualifier {
        
        private boolean isPinned;
        
        PinQualifier(boolean isPinned) {
            this.isPinned = isPinned;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return (task.getImportance() == this.isPinned);
        }
    }
    
    /**
     * Qualifier to check the Completed property of the underlying Task.
     * @author Syed Abdullah
     *
     */
    private class CompletedQualifier implements Qualifier {
        
        private boolean isCompleted;
        
        CompletedQualifier(boolean isCompleted) {
            this.isCompleted = isCompleted;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return (task.getComplete() == this.isCompleted);
        }
    }
    
```
###### \java\seedu\task\model\task\DateTime.java
``` java
    private static final String DATE_TIME_DISPLAY_FORMAT = "%s (%s)";
```
###### \java\seedu\task\model\task\DateTime.java
``` java
    /**
     * Constructs an empty DateTime
     */
    public DateTime() {
        this.value = Optional.empty();
    }
    
    /**
     * Constructs a DateTime from an Instant
     * @param dateTime the Instant of the time and date to be represented
     */
    public DateTime(Instant dateTime) {
        if (dateTime == null) {
            this.value = Optional.empty();
            return;
        }

        this.value = Optional.of(dateTime.truncatedTo(ChronoUnit.MINUTES));
    }

    /**
     * Validates given Date and Time entered by the user.
     * @param dateTime the String representation of the input from the user
     * @throws IllegalValueException if given date/time string is invalid.
     */
    public static DateTime fromUserInput(String dateTime) throws IllegalValueException {
        if (dateTime == null || dateTime.equals("")) {
            return new DateTime(null);
        }
        
        if (!isValidDateTime(dateTime)) {
            throw new IllegalValueException(MESSAGE_DATETIME_CONSTRAINTS);
        }
        
        List<Date> possibleDates = new PrettyTimeParser().parse(dateTime);
        return new DateTime(possibleDates.get(0).toInstant());
    }
    
    /**
     * Create a new DateTime object using the number of milliseconds from 01-01-1970
     * @param epochMilli the number of milliseconds elapsed from the epoch
     * @return a new DateTime object for the specified epoch offset
     */
    public static DateTime fromEpoch(Long epochMilli) {
        if (epochMilli == null) {
            return new DateTime(null);
        }
        
        return new DateTime(Instant.ofEpochMilli(epochMilli));
    }
    
    /**
     * Creates a new DateTime based off an offset from another DateTime
     * @param offsetFrom the DateTime to offset from
     * @param amountToAdd the amount of the specified unit to add to the DateTime
     * @param unit the time unit of the amount
     * @return a new DateTime object with a value that is offset from another DateTime
     */
    public static DateTime fromDateTimeOffset(DateTime offsetFrom, long amountToAdd, TemporalUnit unit) {
        if (offsetFrom == null || offsetFrom.isEmpty()) {
            return new DateTime(null);
        }
        
        Instant offsetInstant = offsetFrom.value.get();
        return new DateTime(offsetInstant.plus(amountToAdd, unit));
    }

```
###### \java\seedu\task\model\task\DateTime.java
``` java
    /**
     * Gets a display friendly representation of the DateTime
     * @return A String containing the display friendly version
     */
    public String toDisplayString() {
        if (this.toString().isEmpty()) {
            return "";
        } else {
            return String.format(DATE_TIME_DISPLAY_FORMAT, this.toString(), this.toPrettyString());
        }
    }
    
    /**
     * Retrieves an ISO 8601 representation of the DateTime.
     * @return A String containing the ISO-8601 representation or empty, if there's
     * no DateTime value
     */
    public String toISOString() {
        if (this.value.isPresent()) {
            return this.value.get().toString();
        } else {
            return "";
        }
    }

    public Long getSaveableValue() {
        if(value.isPresent()) {
            return this.value.get().toEpochMilli();
        } else {
            return null;
        }
    }
    
    /**
     * Compares between two DateTime instances using Comparable.
     * Empty DateTimes are ordered behind all possible non-empty DateTimes.
     */
    @Override
    public int compareTo(DateTime o) {
        Optional<Instant> time = this.value;
        Optional<Instant> otherTime = o.getDateTimeValue();
        
        if (!time.isPresent() && !otherTime.isPresent()) {
            return 0;
        } else if (!time.isPresent()) {
            return 1;
        } else if (!otherTime.isPresent()) {
            return -1;
        } else {
            return time.get().compareTo(otherTime.get());
        }
    }
```
###### \java\seedu\task\model\task\Name.java
``` java
    @Override
    public int compareTo(Name o) {
        return this.taskName.compareToIgnoreCase(o.taskName);
    }
```
###### \java\seedu\task\model\task\ReadOnlyTask.java
``` java
    /**
     * Equality based on what is shown to the user. Useful for tests.
     */
    default boolean isSameVisualStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                  
                // state checks here onwards
                && other.getName().equals(this.getName()) 
                && other.getOpenTime().toDisplayString().equals(this.getOpenTime().toDisplayString())
                && other.getCloseTime().toDisplayString().equals(this.getCloseTime().toDisplayString())
                && other.getImportance() == this.getImportance());
    }
```
###### \java\seedu\task\model\task\Task.java
``` java
    /**
     * Retrieves an immutable version of the task. Will not mutate if task is changed afterwards.
     */
    public ReadOnlyTask getImmutable() {
        try {
            return new Task(this);
        } catch (IllegalValueException e) {
            assert false : "Impossible situation, as Task fields has been validated!";
            return null;
        }
    }
    
```
###### \java\seedu\task\model\task\Task.java
``` java
    /**
     * Uses Comparator.compareTo.
     * The comparison is based on:<br/>
     * - Starred tasks have higher priority<br/>
     * - Completed tasks have lower priority<br/>
     * - For tasks with same completion/starred status,
     *   base comparison on endDate and the task name
     */
    @Override
    public int compareTo(Task o) {
        /*
         * The (^) operator is also a logical XOR, according to Java Language Standards 15.22.2.
         * See: https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.22.2
         */
        if (this.isCompleted ^ o.getComplete()) {
            return (this.isCompleted) ? 1 : -1;
        } else if (this.isImportant ^ o.getImportance()) {
            return (this.isImportant) ? -1 : 1;
        }
        
        int timeComparison = this.closeTime.compareTo(o.getCloseTime());
        
        if (timeComparison == 0) {
            return this.name.compareTo(o.getName());
        } else {
            return timeComparison;
        }
    }
}
```
###### \java\seedu\task\ui\CommandBox.java
``` java
        this.liveSearchHandler = new ChangeListener<String>(){
            @Override
            public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
                Platform.runLater(new Runnable() {
                    @Override public void run() {
                        logic.updateTaskListFilter(newValue);
                    }
                });
            }
        };
        this.isSearchMode = false;
```
###### \java\seedu\task\ui\CommandBox.java
``` java
        if (isSearchMode) {
            // Will always set back on enter and ensure that command is not executed!
            setToCommandBox();
            commandTextField.setText("");
```
###### \java\seedu\task\ui\CommandBox.java
``` java
    @Subscribe
    private void handleSwitchCommandBoxFunction(SwitchCommandBoxFunctionEvent event) {
        setToLiveSearch();
    }
    
    private void setToLiveSearch() {
        commandTextField.setPromptText(TEXT_LIVE_SEARCH);
        this.isSearchMode = true;
        commandTextField.textProperty().addListener(liveSearchHandler);
    }
    
    private void setToCommandBox() {
        commandTextField.setPromptText(TEXT_COMMAND_BOX);
        this.isSearchMode = false;
        commandTextField.textProperty().removeListener(liveSearchHandler);
    }

```
###### \java\seedu\task\ui\TabBarItem.java
``` java
package seedu.task.ui;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;

public class TabBarItem extends UiPart {
    private static final String FXML = "TabBarItem.fxml";
    
    private String tabLabel;
    
    @FXML
    private HBox tabBarNameContainer;
    @FXML
    private Label tabName;
    
    public static TabBarItem load(String tabLabel) {
        TabBarItem tabBar = new TabBarItem();
        tabBar.tabLabel = tabLabel;
        return UiPartLoader.loadUiPart(tabBar);
    }
    
    @FXML
    public void initialize() {
        tabName.setText(tabLabel);
    }
    
    public HBox getLayout() {
        return tabBarNameContainer;
    }

    @Override
    public void setNode(Node node) {
        tabBarNameContainer = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

}
```
